{"name":"P#","tagline":"a language for safer asynchronous .NET programming","body":"P#\r\n====================\r\n**P#** is an **actor-based** programming language for developing **highly-reliable asynchronous software**, such as web-services and distributed systems.\r\n\r\nThe language has **four key capabilities**:\r\n\r\n- Enables the development of efficient asynchronous applications using an **event-driven**, actor-based programming model. Because **all the asynchrony is explicitly exposed** at specific communication points in a P# program, the user does not need to explicitly create and manage tasks; the P# runtime is instead responsible for handling all the underlying concurrency.\r\n- Allows the environment to be **modeled** via language constructs. The compiler can then automatically substitute real code with modeled, and **systematically test** the compiled executable to discover bugs (such as assertion failures and uncaught exceptions).\r\n- Provides strong **data race freedom** guarantees. The compiler is able to perform a **scalable static data race analysis** on the source code that can detect all potential data races in a program (based on certain assumptions, such as no use of non-P# threading or reflection).\r\n- Fully interoperates with C#: the developer can **write any C# code** inside a P# program. P# is basically an extension of C#, build on top of the Roslyn and .NET frameworks, which not only makes P# easy to learn comparing with a completely new language, but also allows **easy integration with existing code**.\r\n\r\n## Build instructions\r\n1. Get Visual Studio 2015 Preview (required for Microsoft Roslyn).\r\n2. Clone this project and compile using VS2015.\r\n3. Get the [Visual Studio 2015 SDK](https://www.microsoft.com/en-us/download/details.aspx?id=46850) to be able to compile the P# visual studio extension (syntax highlighting).\r\n\r\n## How to use\r\nA good way to start is by reading the [manual](https://cdn.rawgit.com/p-org/PSharp/master/Docs/Manual/out/manual.pdf).\r\n\r\nThe P# compiler can be used to parse a program, statically analyse it for data races and finally compile it to an executable. To invoke the compiler use the following command:\r\n\r\n```\r\n.\\PSharpCompiler.exe /s:${SOLUTION_PATH}\\${SOLUTION_NAME}.sln\r\n```\r\n\r\nWhere ${SOLUTION\\_PATH} is the path to your P# solution and ${SOLUTION\\_NAME} is the name of your P# solution.\r\n\r\nTo specify an output path destination use the option `/o:${OUTPUT\\_PATH}`.\r\n\r\nTo compile only a specific project in the solution use the option `/p:${PROJECT_NAME}`.\r\n\r\n## Options\r\n\r\nTo see various available command line options use the option `/?`.\r\n\r\nTo statically analyze the program for data races use the option `/analyze`.\r\n\r\nTo systematically test the program for bugs (i.e. assertion failures and exceptions) use the option `/test`. You can optionally give the number of testing iterations to perform using `/i:value`.\r\n\r\n## Publications\r\n- **[Asynchronous Programming, Analysis and Testing with State Machines](https://dl.acm.org/citation.cfm?id=2737996)**. Pantazis Deligiannis, Alastair F. Donaldson, Jeroen Ketema, Akash Lal and Paul Thomson. In the *ACM SIGPLAN Conference on Programming Language Design and Implementation* (PLDI), 2015.","google":"UA-60025500-2","note":"Don't delete this file! It's used internally to help with page regeneration."}